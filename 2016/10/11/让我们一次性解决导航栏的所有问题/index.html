<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/NGeLBGithub.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/NGeLBGithub.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/NGeLBGithub.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/NGeLBGithub.io/favicon.ico?v=5.1.0" />






<meta name="description" content="系统默认导航栏的返回按钮和返回方式在默认情况下，导航栏返回按钮长这个样子

导航栏左上角的返回按钮，其文本默认为上一个ViewController的标题，如果上一个ViewController没有标题，则为Back（中文环境下为“返回”）。

在默认情况下，导航栏返回的点击交互和滑动交互如下
这些东西不需要任何设置和操作，因此也没有其他需要说明的地方。
自定义左上角的返回按钮绝大多数情况下，我们都">
<meta property="og:type" content="article">
<meta property="og:title" content="让我们一次性解决导航栏的所有问题">
<meta property="og:url" content="https://ngelb.github.io/2016/10/11/让我们一次性解决导航栏的所有问题/index.html">
<meta property="og:site_name" content="NGeLB'S BLOG">
<meta property="og:description" content="系统默认导航栏的返回按钮和返回方式在默认情况下，导航栏返回按钮长这个样子

导航栏左上角的返回按钮，其文本默认为上一个ViewController的标题，如果上一个ViewController没有标题，则为Back（中文环境下为“返回”）。

在默认情况下，导航栏返回的点击交互和滑动交互如下
这些东西不需要任何设置和操作，因此也没有其他需要说明的地方。
自定义左上角的返回按钮绝大多数情况下，我们都">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-0439fbdc6696c284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-c4db48f83aa76dc7.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-47f22e99c56bac65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-86f88da8370653c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-e5357a83b55d033c.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-dc5fadb797c1a397.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1455851-6600cd298d5fb809.gif?imageMogr2/auto-orient/strip">
<meta property="og:updated_time" content="2017-02-28T06:10:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="让我们一次性解决导航栏的所有问题">
<meta name="twitter:description" content="系统默认导航栏的返回按钮和返回方式在默认情况下，导航栏返回按钮长这个样子

导航栏左上角的返回按钮，其文本默认为上一个ViewController的标题，如果上一个ViewController没有标题，则为Back（中文环境下为“返回”）。

在默认情况下，导航栏返回的点击交互和滑动交互如下
这些东西不需要任何设置和操作，因此也没有其他需要说明的地方。
自定义左上角的返回按钮绝大多数情况下，我们都">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1455851-0439fbdc6696c284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/NGeLBGithub.io/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ngelb.github.io/2016/10/11/让我们一次性解决导航栏的所有问题/"/>





  <title> 让我们一次性解决导航栏的所有问题 | NGeLB'S BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/NGeLBGithub.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NGeLB'S BLOG</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">95后的程序猿一枚,目前就职于一家初创公司。</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/NGeLBGithub.io/首页" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/NGeLBGithub.io/分类" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/NGeLBGithub.io/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/NGeLBGithub.io/搜索" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-search"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://ngelb.github.io/NGeLBGithub.io/2016/10/11/让我们一次性解决导航栏的所有问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="NGeLB">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1450561/636896afa3bb.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NGeLB'S BLOG">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NGeLB'S BLOG" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                让我们一次性解决导航栏的所有问题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-11T07:31:31+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h5 id="系统默认导航栏的返回按钮和返回方式"><a href="#系统默认导航栏的返回按钮和返回方式" class="headerlink" title="系统默认导航栏的返回按钮和返回方式"></a>系统默认导航栏的返回按钮和返回方式</h5><p>在默认情况下，导航栏返回按钮长这个样子<br><img src="http://upload-images.jianshu.io/upload_images/1455851-0439fbdc6696c284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导航栏默认返回按钮"></p>
<blockquote>
<p>导航栏左上角的返回按钮，其文本默认为上一个ViewController的标题，如果上一个ViewController没有标题，则为Back（中文环境下为“返回”）。</p>
</blockquote>
<p>在默认情况下，导航栏返回的点击交互和滑动交互如下<br><img src="http://upload-images.jianshu.io/upload_images/1455851-c4db48f83aa76dc7.gif?imageMogr2/auto-orient/strip" alt="默认导航栏交互"></p>
<p>这些东西不需要任何设置和操作，因此也没有其他需要说明的地方。</p>
<h5 id="自定义左上角的返回按钮"><a href="#自定义左上角的返回按钮" class="headerlink" title="自定义左上角的返回按钮"></a>自定义左上角的返回按钮</h5><p>绝大多数情况下，我们都需要根据产品需求自定义左上角的返回按钮，虽然这对大多数开发者来说不是什么难事，但依然有几个问题值得注意。</p>
<p><strong>替换左上角返回按钮</strong></p>
<p>替换返回按钮非常简单，只需要在ViewController中创建一个UIBarButtonItem和一张图片，并为按钮添加响应的点击事件即可，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view.</div><div class="line"></div><div class="line">UIButton * leftBtn = [UIButton buttonWithType:UIButtonTypeSystem];</div><div class="line">leftBtn.frame = CGRectMake(0, 0, 25,25);</div><div class="line">[leftBtn setBackgroundImage:[UIImage imageNamed:@&quot;nav_back&quot;] forState:UIControlStateNormal];</div><div class="line">[leftBtn addTarget:self action:@selector(leftBarBtnClicked:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithCustomView:leftBtn];</div><div class="line">&#125;</div><div class="line">- (void)leftBarBtnClicked:(UIButton *)btn</div><div class="line">&#123;</div><div class="line"> [self.navigationController popViewControllerAnimated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一眼效果：<br><img src="http://upload-images.jianshu.io/upload_images/1455851-47f22e99c56bac65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="替换返回按钮"></p>
<h5 id="调整按钮位置"><a href="#调整按钮位置" class="headerlink" title="调整按钮位置"></a>调整按钮位置</h5><p>我们可以看到，上面的按钮是有点偏右的，那如果我们想调整按钮的位置该怎么做呢？设置Frame显然是行不通的，因为导航栏的Navigation是个比较特殊的View，我们无法通过简单的调整Frame来的调整左右按钮的位置。但是在苹果提供的<code>UIButtonBarItem</code>中有个叫做<code>UIBarButtonSystemItemFixedSpace</code>的控件，利用它，我们就可以轻松调整返回按钮的位置。具体使用方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//创建返回按钮</div><div class="line">UIButton * leftBtn = [UIButton buttonWithType:UIButtonTypeSystem];</div><div class="line">leftBtn.frame = CGRectMake(0, 0, 25,25);</div><div class="line">[leftBtn setBackgroundImage:[UIImage imageNamed:@&quot;icon_back&quot;] forState:UIControlStateNormal];</div><div class="line">[leftBtn addTarget:self action:@selector(leftBarBtnClicked:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">UIBarButtonItem * leftBarBtn = [[UIBarButtonItem alloc]initWithCustomView:leftBtn];;</div><div class="line">//创建UIBarButtonSystemItemFixedSpace</div><div class="line">UIBarButtonItem * spaceItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];</div><div class="line">//将宽度设为负值</div><div class="line">spaceItem.width = -15;</div><div class="line">//将两个BarButtonItem都返回给NavigationItem</div><div class="line">self.navigationItem.leftBarButtonItems = @[spaceItem,leftBarBtn];</div></pre></td></tr></table></figure>
<p>我们来看一眼效果：<br><img src="http://upload-images.jianshu.io/upload_images/1455851-86f88da8370653c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调整返回按钮位置"></p>
<p>可以看到，我们的返回按钮已经紧靠着屏幕边缘。</p>
<blockquote>
<p>这个方法同样适用于调整导航栏右侧的按钮</p>
</blockquote>
<h5 id="让滑动返回手势生效"><a href="#让滑动返回手势生效" class="headerlink" title="让滑动返回手势生效"></a>让滑动返回手势生效</h5><p>如果使用自定义的按钮去替换系统默认返回按钮，会出现滑动返回手势失效的情况。解决方法也很简单，只需要重新添加导航栏的<code>interactivePopGestureRecognizer</code>的<code>delegate</code>即可。<br>首先ViewController添加<code>UIGestureRecognizerDelegate</code>协议</p>
<p>然后设置代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.interactivePopGestureRecognizer.delegate = self;</div></pre></td></tr></table></figure>
<p>至此，我们已经将返回按钮替换为我们的自定义按钮，并使滑动返回重新生效。接下来，我们继续来解决交互上的问题。</p>
<h5 id="全屏滑动返回"><a href="#全屏滑动返回" class="headerlink" title="全屏滑动返回"></a>全屏滑动返回</h5><p>这个一个很常见的需求，网上解决方案也很多，这里将本人常用的方法贴到这里。仅供参考<br>实现全屏滑动返回仅需在导航栏给导航栏添加<code>UIGestureRecognizerDelegate</code>协议，并在ViewDidLoad中写入如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 获取系统自带滑动手势的target对象</div><div class="line">id target = self.interactivePopGestureRecognizer.delegate;</div><div class="line"></div><div class="line">// 创建全屏滑动手势，调用系统自带滑动手势的target的action方法</div><div class="line">UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];</div><div class="line"></div><div class="line">// 设置手势代理，拦截手势触发</div><div class="line">pan.delegate = self;</div><div class="line"></div><div class="line">// 给导航控制器的view添加全屏滑动手势</div><div class="line">[self.view addGestureRecognizer:pan];</div><div class="line"></div><div class="line">// 禁止使用系统自带的滑动手势</div><div class="line">self.interactivePopGestureRecognizer.enabled = NO;</div></pre></td></tr></table></figure>
<p>我们来看一眼效果（注意鼠标位置）<br><img src="http://upload-images.jianshu.io/upload_images/1455851-e5357a83b55d033c.gif?imageMogr2/auto-orient/strip" alt="全屏滑动返回.gif"></p>
<p>成功</p>
<blockquote>
<p>这种方法的原理其实很简单，其实就是自定义一个全屏滑动手势，并将滑动事件设置为系统滑动事件，然后禁用系统滑动手势即可。<code>handleNavigationTransition</code>就是系统滑动的方法，虽然系统并未提供接口，但是我们我们可以通过runtime找到这个方法，因此直接调用即可。两位，不必担心什么私有API之类的问题，苹果如果按照方法名去判断是否使用私有API，那得误伤多少App。</p>
</blockquote>
<h5 id="NavigationBar切换动画的“终极解决方案”"><a href="#NavigationBar切换动画的“终极解决方案”" class="headerlink" title="NavigationBar切换动画的“终极解决方案”"></a>NavigationBar切换动画的“终极解决方案”</h5><blockquote>
<p>本部分文字代码都较多，不想看这么多废话的同学请直接翻到末尾，文末附有下载地址，导入项目后，继承即可生效。</p>
</blockquote>
<p>在改变了导航栏样式，实现了全屏滑动返回之后，我们有了一个看起来还不错的导航栏。但是我们滑动时的切换依然是系统自带的动画，如果遇到前一个界面的<code>NavigationBar</code>为透明或前后两个Bar颜色不一样，这种渐变式的动画看起来就会不太友好，尤其当前后两个界面其中一个界面的NavigationBar为透明或隐藏时，其效果更是惨不忍睹。</p>
<p>这个问题，其实很多App，比如天猫、美团等都通过一种“整体返回”的效果来解决这个问题。效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1455851-dc5fadb797c1a397.gif?imageMogr2/auto-orient/strip" alt="整体滑动返回"></p>
<p>这种解决方案等于将两个NavigationBar独立开来，因此可以相对完美的解决导航栏滑动切换中的种种Bug。<br>接下来，我们来看看如何实现这种效果。</p>
<p><strong>基本原理</strong><br>以我个人的认知，实现这个效果有三种基本思路：</p>
<blockquote>
<ol>
<li>使用<code>UINavigationController</code>自带的<code>setNavigationBarHidden: animated:</code>方法来实现，每次push或pop时，在当前控制器的<code>viewWillDisappear:</code>中设置隐藏，在要跳转的控制器的<code>viewWillAppear:</code>中设置导航栏显示。</li>
<li>在每次Push前对当前页面进行截图并保存到数组，Pop时取数组最后一个元素显示，滑动结束后调用系统Pop方法并删除最后一张截图。</li>
<li>使用iOS 7之后开放的，<code>UIViewControllerAnimatedTransitioning</code>协议，来实现自定义导航栏转场动画及交互。</li>
</ol>
</blockquote>
<p>以上三种方法，方法一十分繁琐，而且会有很多莫名其妙的bug，直接pass。</p>
<p>在iOS的交互中，push一般通过按钮的点击事件或View的<code>tap</code>事件触发，而pop则可能通过事件触发，也可能通过右滑手势触发。因此，我们将这个我们要实现的动画效果分为交互效果和无交互效果两种，下面我们将使用方法2和方法3提供的思路，分别实现这两种效果，这样就能较为完美的解决Push和Pop的动画问题。</p>
<h5 id="实现交互动画效果"><a href="#实现交互动画效果" class="headerlink" title="实现交互动画效果"></a>实现交互动画效果</h5><p><strong>准备需要使用的数组及手势</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#define ScreenWidth [UIScreen mainScreen].bounds.size.width</div><div class="line">#define ScreenHeight [UIScreen mainScreen].bounds.size.height</div><div class="line">@interface LTNavigationController ()&lt;UIGestureRecognizerDelegate&gt;</div><div class="line">@property(strong,nonatomic)UIImageView * screenshotImgView;</div><div class="line">@property(strong,nonatomic)UIView * coverView;</div><div class="line">@property(strong,nonatomic)NSMutableArray * screenshotImgs;</div><div class="line">@property(strong,nonatomic)UIPanGestureRecognizer *panGestureRec;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LTNavigationController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view.</div><div class="line"></div><div class="line">// 1,创建Pan手势识别器,并绑定监听方法</div><div class="line">_panGestureRec = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(panGestureRec:)];</div><div class="line">_panGestureRec.edges = UIRectEdgeLeft;</div><div class="line">// 为导航控制器的view添加Pan手势识别器</div><div class="line">[self.view addGestureRecognizer:_panGestureRec];</div><div class="line"></div><div class="line">// 2.创建截图的ImageView</div><div class="line">_screenshotImgView = [[UIImageView alloc] init];</div><div class="line">// app的frame是包括了状态栏高度的frame</div><div class="line">_screenshotImgView.frame = CGRectMake(0, 0, ScreenWidth, ScreenHeight);</div><div class="line"></div><div class="line"></div><div class="line">// 3.创建截图上面的黑色半透明遮罩</div><div class="line">_coverView = [[UIView alloc] init];</div><div class="line">// 遮罩的frame就是截图的frame</div><div class="line">_coverView.frame = _screenshotImgView.frame;</div><div class="line">// 遮罩为黑色</div><div class="line">_coverView.backgroundColor = [UIColor blackColor];</div><div class="line"></div><div class="line">// 4.存放所有的截图数组初始化</div><div class="line">_screenshotImgs = [NSMutableArray array];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实现手势的相应事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">// 响应手势的方法</div><div class="line">- (void)panGestureRec:(UIPanGestureRecognizer *)panGestureRec</div><div class="line">&#123;</div><div class="line"></div><div class="line">// 如果当前显示的控制器已经是根控制器了，不需要做任何切换动画,直接返回</div><div class="line">if(self.visibleViewController == self.viewControllers[0]) return;</div><div class="line">// 判断pan手势的各个阶段</div><div class="line">switch (panGestureRec.state) &#123;</div><div class="line">    case UIGestureRecognizerStateBegan:</div><div class="line">        // 开始拖拽阶段</div><div class="line">        [self dragBegin];</div><div class="line">        break;</div><div class="line"></div><div class="line">    case UIGestureRecognizerStateEnded:</div><div class="line">        // 结束拖拽阶段</div><div class="line">        [self dragEnd];</div><div class="line">        break;</div><div class="line"></div><div class="line">    default:</div><div class="line">        // 正在拖拽阶段</div><div class="line">        [self dragging:panGestureRec];</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 开始拖动,添加图片和遮罩</div><div class="line">- (void)dragBegin</div><div class="line">&#123;</div><div class="line">// 重点,每次开始Pan手势时,都要添加截图imageview 和 遮盖cover到window中</div><div class="line">[self.view.window insertSubview:_screenshotImgView atIndex:0];</div><div class="line">[self.view.window insertSubview:_coverView aboveSubview:_screenshotImgView];</div><div class="line"></div><div class="line">// 并且,让imgView显示截图数组中的最后(最新)一张截图</div><div class="line">_screenshotImgView.image = [_screenshotImgs lastObject];</div><div class="line">//_screenshotImgView.transform = CGAffineTransformMakeTranslation(ScreenWidth, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 默认的将要变透明的遮罩的初始透明度(全黑)</div><div class="line">#define kDefaultAlpha 0.6</div><div class="line"></div><div class="line">// 当拖动的距离,占了屏幕的总宽高的3/4时, 就让imageview完全显示，遮盖完全消失</div><div class="line">#define kTargetTranslateScale 0.75</div><div class="line">#pragma mark 正在拖动,动画效果的精髓,进行位移和透明度变化</div><div class="line">- (void)dragging:(UIPanGestureRecognizer *)pan</div><div class="line">&#123;</div><div class="line"></div><div class="line">// 得到手指拖动的位移</div><div class="line">CGFloat offsetX = [pan translationInView:self.view].x;</div><div class="line"></div><div class="line">// 让整个view都平移     // 挪动整个导航view</div><div class="line">if (offsetX &gt; 0) &#123;</div><div class="line">    self.view.transform = CGAffineTransformMakeTranslation(offsetX, 0);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">// 计算目前手指拖动位移占屏幕总的宽高的比例,当这个比例达到3/4时, 就让imageview完全显示，遮盖完全消失</div><div class="line">double currentTranslateScaleX = offsetX/self.view.frame.size.width;</div><div class="line"></div><div class="line">if (offsetX &lt; ScreenWidth) &#123;</div><div class="line"></div><div class="line">    _screenshotImgView.transform = CGAffineTransformMakeTranslation((offsetX - ScreenWidth) * 0.6, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 让遮盖透明度改变,直到减为0,让遮罩完全透明,默认的比例-(当前平衡比例/目标平衡比例)*默认的比例</div><div class="line">double alpha = kDefaultAlpha - (currentTranslateScaleX/kTargetTranslateScale) * kDefaultAlpha;</div><div class="line">_coverView.alpha = alpha;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 结束拖动,判断结束时拖动的距离作相应的处理,并将图片和遮罩从父控件上移除</div><div class="line">- (void)dragEnd</div><div class="line">&#123;</div><div class="line">// 取出挪动的距离</div><div class="line">CGFloat translateX = self.view.transform.tx;</div><div class="line">// 取出宽度</div><div class="line">CGFloat width = self.view.frame.size.width;</div><div class="line"></div><div class="line">if (translateX &lt;= 40) &#123;</div><div class="line">    // 如果手指移动的距离还不到屏幕的一半,往左边挪 (弹回)</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        // 重要~~让被右移的view弹回归位,只要清空transform即可办到</div><div class="line">        self.view.transform = CGAffineTransformIdentity;</div><div class="line">        // 让imageView大小恢复默认的translation</div><div class="line">        _screenshotImgView.transform = CGAffineTransformMakeTranslation(-ScreenWidth, 0);</div><div class="line">        // 让遮盖的透明度恢复默认的alpha 1.0</div><div class="line">        _coverView.alpha = kDefaultAlpha;</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        // 重要,动画完成之后,每次都要记得 移除两个view,下次开始拖动时,再添加进来</div><div class="line">        [_screenshotImgView removeFromSuperview];</div><div class="line">        [_coverView removeFromSuperview];</div><div class="line">    &#125;];</div><div class="line">&#125; else &#123;</div><div class="line">    // 如果手指移动的距离还超过了屏幕的一半,往右边挪</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        // 让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform</div><div class="line">        self.view.transform = CGAffineTransformMakeTranslation(width, 0);</div><div class="line">        // 让imageView位移还原</div><div class="line">        _screenshotImgView.transform = CGAffineTransformMakeTranslation(0, 0);</div><div class="line">        // 让遮盖alpha变为0,变得完全透明</div><div class="line">        _coverView.alpha = 0;</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        // 重要~~让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform,不然下次再次开始drag时会出问题,因为view的transform没有归零</div><div class="line">        self.view.transform = CGAffineTransformIdentity;</div><div class="line">        // 移除两个view,下次开始拖动时,再加回来</div><div class="line">        [_screenshotImgView removeFromSuperview];</div><div class="line">        [_coverView removeFromSuperview];</div><div class="line"></div><div class="line">        // 执行正常的Pop操作:移除栈顶控制器,让真正的前一个控制器成为导航控制器的栈顶控制器</div><div class="line">        [self popViewControllerAnimated:NO];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实现截图保存功能，并在Push前截图</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)screenShot</div><div class="line">&#123;</div><div class="line">// 将要被截图的view,即窗口的根控制器的view</div><div class="line">UIViewController *beyondVC = self.view.window.rootViewController;</div><div class="line">// 背景图片 总的大小</div><div class="line">CGSize size = beyondVC.view.frame.size;</div><div class="line">// 开启上下文,使用参数之后,截出来的是原图（YES  0.0 质量高）</div><div class="line">UIGraphicsBeginImageContextWithOptions(size, YES, 0.0);</div><div class="line">// 要裁剪的矩形范围</div><div class="line">CGRect rect = CGRectMake(0, 0, ScreenWidth, ScreenHeight);</div><div class="line">//注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代</div><div class="line">[beyondVC.view drawViewHierarchyInRect:rect  afterScreenUpdates:NO];</div><div class="line">// 从上下文中,取出UIImage</div><div class="line">UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">// 添加截取好的图片到图片数组</div><div class="line">if (snapshot) &#123;</div><div class="line">    [_screenshotImgs addObject:snapshot];</div><div class="line">&#125;</div><div class="line">// 千万记得,结束上下文(移除栈顶的基于当前位图的图形上下文)</div><div class="line">UIGraphicsEndImageContext();</div><div class="line">&#125;</div><div class="line">- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">  //有在导航控制器里面有子控制器的时候才需要截图</div><div class="line">if (self.viewControllers.count &gt;= 1) &#123;</div><div class="line">    // 调用自定义方法,使用上下文截图</div><div class="line">    [self screenShot];</div><div class="line">&#125;</div><div class="line">// 截图完毕之后,才调用父类的push方法</div><div class="line">[super pushViewController:viewController animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>重写常用的pop方法</strong></p>
<p>在一开始基本原理地方，我们说过pop时要删除最后一张截图，用来保证数组中的最后一张截图是上一个控制器，但是很多情况下我们可能调用的是导航栏的<code>popToViewController: animated:</code>方法或<code>popToRootViewControllerAnimated:</code>来返回，这种情况下，我们删除的可能就不是一张截图，因此我们需要分别重写这些Pop方法，去确定我们要删除多少张图片，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)popViewControllerAnimated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">   [_screenshotImgs removeLastObject];</div><div class="line">   return [super popViewControllerAnimated:animated];</div><div class="line">&#125;</div><div class="line">- (NSArray&lt;UIViewController *&gt; *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">for (NSInteger i = self.viewControllers.count - 1; i &gt; 0; i--) &#123;</div><div class="line">    if (viewController == self.viewControllers[i]) &#123;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    [_screenshotImgs removeLastObject];</div><div class="line">&#125;</div><div class="line"></div><div class="line">return [super popToViewController:viewController animated:animated];</div><div class="line">&#125;</div><div class="line">- (NSArray&lt;UIViewController *&gt; *)popToRootViewControllerAnimated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">[_screenshotImgs removeAllObjects];</div><div class="line">return [super popToRootViewControllerAnimated:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在指定的控制器屏蔽手势</strong></p>
<p>在上面代码中，我们使用的是侧滑手势，并将相应区域设置为屏幕左侧。<br>之所以不用全屏滑动，是因为全屏滑动手势在有些时候会和其他手势冲突，如果冲突的是我们自定义的手势，自然好解决，但如果是系统手势，如TableView的左滑菜单操作，这个事情就很蛋疼的。<br>但是如果必须要做全屏滑动手势的话，我们可以对代码稍作修改，某些控制器中屏蔽手势。</p>
<p>首先给导航栏添加禁用名单数组并配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">@property(nonatomic,copy)NSArray * forbiddenArray;</div><div class="line">...</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//原来代码</div><div class="line">...</div><div class="line">  //将手势禁用，之后在Push时根据条件开启</div><div class="line"> self.panGestureRec.enabled = enable</div><div class="line">//将需要禁用手势的控制器的类名加到这个数组</div><div class="line">self.forbiddenArray = @[@&quot;SCViewController&quot;,@&quot;ManageAddressViewController&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line"></div><div class="line">//在指定控制器中禁用手势  解决滑动返回手势和某些手势冲突问题</div><div class="line">BOOL enable = YES;</div><div class="line">for (NSString * string in self.forbiddenArray) &#123;</div><div class="line">    NSString * className = NSStringFromClass([viewController class]);</div><div class="line">    if ([string isEqualToString:className]) &#123;</div><div class="line">        enable = NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">self.panGestureRec.enabled = enable;</div><div class="line"></div><div class="line">//原有代码</div><div class="line">...</div><div class="line">&#125;</div><div class="line">- (UIViewController *)popViewControllerAnimated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">NSInteger count = self.viewControllers.count;</div><div class="line">NSString * className = nil;</div><div class="line">if (count &gt;= 2) &#123;</div><div class="line">    className = NSStringFromClass([self.viewControllers[count -2] class]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL enable = YES;</div><div class="line">for (NSString * string in self.forbiddenArray) &#123;</div><div class="line">    if ([string isEqualToString:className]) &#123;</div><div class="line">        enable = NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">self.panGestureRec.enabled = enable;</div><div class="line">//原有代码</div><div class="line">...</div><div class="line"></div><div class="line">return [super popViewControllerAnimated:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到了这里，我们已经完成了交互式的切换动画，效果跟开头一样，就不再截图。接下来我们来解决另一个大Boss-非交互式动画</p>
<h4 id="实现非交互动画效果"><a href="#实现非交互动画效果" class="headerlink" title="实现非交互动画效果"></a>实现非交互动画效果</h4><h5 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h5><p>这里我们就要用到之前说的<code>UIViewControllerAnimatedTransitioning</code>来实现。限于篇幅，这里不再详细介绍这部分的基础知识，大家可以移步这两篇博客做一个初步的了解</p>
<p><a href="http://www.jianshu.com/p/f6d48c5814e1" target="_blank" rel="external">向 UINavigationController 的传统动画说”再见” — 自定义过场动画(一)</a><br><a href="http://login.sina.com.cn/sso/login.php?useticket=0&amp;returntype=META&amp;service=blog&amp;gateway=1&amp;url=http://blog.sina.com.cn/s/blog_4ca9ceef0101ic5i.html" target="_blank" rel="external">iOS 7：自定义导航转场动画以及更多</a></p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><blockquote>
<p>注：FromVC代表即将消失的视图控制器，ToVC表示将要展示的视图控制器</p>
</blockquote>
<p><strong>我们要实现的效果</strong><br>Push的时候，FromVC往左移动，ToVC从屏幕右侧出现跟随FromVC左移直至FromVC消失，此时ToVC刚好完整显示在屏幕上。<br>Pop的时候，FromVC向右移动，ToVC从屏幕边缘出现跟随FromVC向右移动直至FromVC消失，此时ToVC刚好完整显示在屏幕上</p>
<p>实现的时候，我们依然需要将Push和Pop分开讨论<br>先说Pop<br>1.和交互式动画一样，每次Push时对屏幕截屏并保存，Pop的再次截屏但不保存<br>2.把Pop时截取的图片作为FromVC展示，把Push到这个界面时截取的图片作为ToVC展示<br>3.并对两张图片做位移动画，动画结束后移除两张图片</p>
<p>然后是Push<br>1.Push时先对当前屏幕截屏。<br>2.将截取的图片保存方便Pop回来时使用，并把这张图片作为这次Push的FromVC保存。<br>3.获取当前导航栏控制器对象，调整其Transform属性中的位移参数作为ToVC展示<br>4.对截图和导航栏做位移，动画结束后直接移除截屏图片</p>
<blockquote>
<p>为什么要对导航栏作位移？<br>首先，在Push结束之前，我们是无法知道ToVC具体是什么样子，系统的截屏方法对于未加载出来的View是无能为力的，而UIView的 <code>snapshotViewAfterScreenUpdates:</code>方法又无法带着导航栏一起映射到一个新的View上，因此视觉效果很差。<br>正好在Pop的时候，为了达到想要的动画效果，用来展示的两张图片都需要放到导航栏的View上，因此在Push的时候我们就直接将导航栏的View做一个放射变换，当然，这也就意味着，当我们Push的时候，截屏就不能再放到导航栏上，而是应该放到它的“更上一层“ – <code>UITabbarController</code>的View上</p>
</blockquote>
<p><strong>让我们撸一发代码</strong></p>
<p>根据上述实现原理，我们可以知道，我们的主要工作重点在于打造一个合适的动画控制器。更准确的说，我们需要实现的细节都在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">```中，由于之前解释的很详细，这里我直接贴上相应代码供参考</div></pre></td></tr></table></figure></p>
<p>-(void)animateTransition:(id<uiviewcontrollercontexttransitioning>)transitionContext<br>{</uiviewcontrollercontexttransitioning></p>
<p>UIImageView <em> screentImgView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight)];<br>UIImage </em> screenImg = [self screenShot];<br>screentImgView.image =screenImg;</p>
<p>//取出fromViewController,fromView和toViewController，toView<br>UIViewController <em> fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];<br>//    UIView </em> fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];<br>UIViewController <em> toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];<br>UIView </em> toView = [transitionContext viewForKey:UITransitionContextToViewKey];</p>
<p>CGRect fromViewEndFrame = [transitionContext finalFrameForViewController:fromViewController];<br>fromViewEndFrame.origin.x = ScreenWidth;<br>CGRect fromViewStartFrame = fromViewEndFrame;<br>CGRect toViewEndFrame = [transitionContext finalFrameForViewController:toViewController];<br>CGRect toViewStartFrame = toViewEndFrame;</p>
<p>UIView * containerView = [transitionContext containerView];</p>
<p>if (self.navigationOperation == UINavigationControllerOperationPush) {</p>
<pre><code>[self.screenShotArray addObject:screenImg];
//toViewStartFrame.origin.x += ScreenWidth;
[containerView addSubview:toView];

toView.frame = toViewStartFrame;

UIView * nextVC = [[UIView alloc]initWithFrame:CGRectMake(ScreenWidth, 0, ScreenWidth, ScreenHeight)];
 //[nextVC addSubview:[toView snapshotViewAfterScreenUpdates:YES]];

[self.navigationController.tabBarController.view insertSubview:screentImgView atIndex:0];

//[self.navigationController.tabBarController.view addSubview:nextVC];
nextVC.layer.shadowColor = [UIColor blackColor].CGColor;
nextVC.layer.shadowOffset = CGSizeMake(-0.8, 0);
nextVC.layer.shadowOpacity = 0.6;

self.navigationController.view.transform = CGAffineTransformMakeTranslation(ScreenWidth, 0);

[UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
    //toView.frame = toViewEndFrame;
self.navigationController.view.transform = CGAffineTransformMakeTranslation(0, 0);
    screentImgView.center = CGPointMake(-ScreenWidth/2, ScreenHeight / 2);
    //nextVC.center = CGPointMake(ScreenWidth/2, ScreenHeight / 2);


} completion:^(BOOL finished) {

    [nextVC removeFromSuperview];
    [screentImgView removeFromSuperview];
    [transitionContext completeTransition:YES];
}];
</code></pre><p>}<br>if (self.navigationOperation == UINavigationControllerOperationPop) {</p>
<pre><code>fromViewStartFrame.origin.x = 0;
[containerView addSubview:toView];
//若removeCount大于0  则说明Pop了不止一个控制器
if (_removeCount &gt; 0) {
    for (NSInteger i = 0; i &lt; _removeCount; i ++) {
        if (i == _removeCount - 1) {
            //当删除到要跳转页面的截图时，不再删除，并将该截图作为ToVC的截图展示
            lastVcImgView.image = [self.screenShotArray lastObject];
            _removeCount = 0;
            break;
        }
        else
        {
            [self.screenShotArray removeLastObject];
        }

    }
}
else
{
    lastVcImgView.image = [self.screenShotArray lastObject];
}
lastVcImgView.image = [self.screenShotArray lastObject];
screentImgView.layer.shadowColor = [UIColor blackColor].CGColor;
screentImgView.layer.shadowOffset = CGSizeMake(-0.8, 0);
screentImgView.layer.shadowOpacity = 0.6;
[self.navigationController.tabBarController.view addSubview:lastVcImgView];
[self.navigationController.tabBarController.view addSubview:screentImgView];
</code></pre><p>   // fromView.frame = fromViewStartFrame;<br>    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{</p>
<pre><code>    screentImgView.center = CGPointMake(ScreenWidth * 3 / 2 , ScreenHeight / 2);
    lastVcImgView.center = CGPointMake(ScreenWidth/2, ScreenHeight/2);
    //fromView.frame = fromViewEndFrame;

} completion:^(BOOL finished) {
    //[self.navigationController setNavigationBarHidden:NO];
    [lastVcImgView removeFromSuperview];
    [screentImgView removeFromSuperview];
    [self.screenShotArray removeLastObject];
    [transitionContext completeTransition:YES];

}];
</code></pre><p>  }</p>
<p>}</p>
<ul>
<li>(void)removeLastScreenShot<br>{<br>[self.screenShotArray removeLastObject];<br>}</li>
<li>(UIImage <em>)screenShot<br>{<br>// 将要被截图的view,即窗口的根控制器的view(必须不含状态栏,默认ios7中控制器是包含了状态栏的)<br>UIViewController </em>beyondVC = self.navigationController.view.window.rootViewController;<br>// 背景图片 总的大小<br>CGSize size = beyondVC.view.frame.size;<br>// 开启上下文,使用参数之后,截出来的是原图（YES  0.0 质量高）<br>UIGraphicsBeginImageContextWithOptions(size, YES, 0.0);<br>// 要裁剪的矩形范围<br>CGRect rect = CGRectMake(0, 0, ScreenWidth, ScreenHeight);<br>//注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代<br>[beyondVC.view drawViewHierarchyInRect:rect  afterScreenUpdates:NO];<br>// 从上下文中,取出UIImage<br>UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext();</li>
</ul>
<p>// 千万记得,结束上下文(移除栈顶的基于当前位图的图形上下文)<br>UIGraphicsEndImageContext();</p>
<p>// 返回截取好的图片<br>return  snapsot;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; 注：`ot;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：removeL`需要在使用滑动手势Pop后调用，用来清除动画控制器中保存的截图，否则当交互式和非交互式动画交替使用时，会出现截图混乱的问题。</p>
<p>更新：</p>
<p>在调用 <code>popToViewController:(UIViewController *)viewController animated:(BOOL)animated</code>一次Pop多个页面，或调用<code>popToRootViewControllerAnimated</code>直接回到跟控制器时，一样需要清除对应数量的截图，并且需要和导航栏配合操作。新的代码已提交github，文章里也已经更新动画控制器对应的部分，具体代码还是以GitHub为准。</p>
</blockquote>
<p><strong>看看效果</strong></p>
<p>我们将动画持续时间调制两秒，观察一下效果<br><img src="http://upload-images.jianshu.io/upload_images/1455851-6600cd298d5fb809.gif?imageMogr2/auto-orient/strip" alt="完成效果.gif"></p>
<p>制作完成的导航栏和动画控制器的下载地址<br><a href="https://github.com/RunningChicken-K/KLTAnimateNav" target="_blank" rel="external">导航栏和动画控制器下载地址</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/NGeLBGithub.io/2016/09/21/一步步教你彻底学会『iOS应用间相互跳转』/" rel="next" title="一步步教你彻底学会『iOS应用间相互跳转』">
                <i class="fa fa-chevron-left"></i> 一步步教你彻底学会『iOS应用间相互跳转』
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/NGeLBGithub.io/2016/10/22/iOS开发中的内存分配（堆和栈）/" rel="prev" title="iOS开发中的内存分配（堆和栈）">
                iOS开发中的内存分配（堆和栈） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://upload.jianshu.io/users/upload_avatars/1450561/636896afa3bb.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240"
               alt="NGeLB" />
          <p class="site-author-name" itemprop="name">NGeLB</p>
          <p class="site-description motion-element" itemprop="description">自己平时喜欢逛一些博客和论坛，收录了一些有价值的文章，虽然大部分文章是转载，但是都被重新排版、重新编辑，并且都标明了转载地址。</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/NGeLBGithub.io/">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/NGeLB" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/your-user-name" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#系统默认导航栏的返回按钮和返回方式"><span class="nav-number">1.</span> <span class="nav-text">系统默认导航栏的返回按钮和返回方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义左上角的返回按钮"><span class="nav-number">2.</span> <span class="nav-text">自定义左上角的返回按钮</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#调整按钮位置"><span class="nav-number">3.</span> <span class="nav-text">调整按钮位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#让滑动返回手势生效"><span class="nav-number">4.</span> <span class="nav-text">让滑动返回手势生效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全屏滑动返回"><span class="nav-number">5.</span> <span class="nav-text">全屏滑动返回</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NavigationBar切换动画的“终极解决方案”"><span class="nav-number">6.</span> <span class="nav-text">NavigationBar切换动画的“终极解决方案”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现交互动画效果"><span class="nav-number">7.</span> <span class="nav-text">实现交互动画效果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现非交互动画效果"><span class="nav-number"></span> <span class="nav-text">实现非交互动画效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#理论基础"><span class="nav-number">1.</span> <span class="nav-text">理论基础</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现原理"><span class="nav-number">2.</span> <span class="nav-text">实现原理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NGeLB</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/NGeLBGithub.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/NGeLBGithub.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/NGeLBGithub.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/NGeLBGithub.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/NGeLBGithub.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/NGeLBGithub.io/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/NGeLBGithub.io/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/NGeLBGithub.io/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
